
from cryptography.hazmat.primitives import hashes, hmac, padding
from cryptography.hazmat.primitives.constant_time import bytes_eq
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import rsa, ec
from cryptography.hazmat.primitives import constant_time
import secrets
from cryptography.hazmat.primitives import hmac, hashes
from cryptography.exceptions import InvalidSignature
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives import hashes



class CryptoException(Exception):
    '''
    Custom exception class
    The below functions should raise exceptions of this class when any error is encountered.
    The code from this file should never raise an exception of any other class.
    Example usage:
        try:
            ...
        except TypeError:
            raise CryptoException("Data value must be in bytes")
    '''
    pass
def generate_random_securely(size=None):
    """
    Generate random bytes using Python secrets library

    :param size: number of bytes required (integer)
    :return: randomly generated bytes (byte string)
    """
    if size is None:
        raise CryptoException("Size is required for generating random bytes")
    return secrets.token_bytes(size)

def hash_message(data, hash_method):
    """
    Perform hash on data

    :param data: the data to hash (byte string)
    :param hash_method: the hash function to use -- one of "SHA256" or "SHA512" (string)
    :return: hash of the data (byte string)
    """
    if not isinstance(data, bytes):
        raise CryptoException("Data value must be in bytes")
    if hash_method == "SHA256":
        digest = hashes.Hash(hashes.SHA256())
    elif hash_method == "SHA512":
        digest = hashes.Hash(hashes.SHA512())
    else:
        raise CryptoException("Unsupported hash method")
    digest.update(data)
    return digest.finalize()

def hmac_message(data, hash_method, key):
    """
    Compute HMAC of data

    :param data: the data to HMAC (byte string)
    :param hash_method: the hash function to use -- one of "SHA256" or "SHA512" (string)
    :param key: the key to use in HMAC (byte string)
    :return: HMAC of the data (byte string)
    """
    if not isinstance(data, bytes):
        raise CryptoException("Data value must be in bytes")
    if not isinstance(key, bytes):
        raise CryptoException("Key value must be in bytes")
    if hash_method == "SHA256":
        digest = hashes.SHA256()
    elif hash_method == "SHA512":
        digest = hashes.SHA512()
    else:
        raise CryptoException("Unsupported hash method")
    h = hmac.HMAC(key, digest)
    h.update(data)
    return h.finalize()

def verify_hash(data, hash_method, mac):
    """
    Verify that a given hash is correct for some data

    :param data: the data on which the hash is supposedly computed (byte string)
    :param hash_method: the hash method supposedly used -- one of "SHA256" or "SHA512" (string)
    :param mac: the hash value to match against (byte string)
    :return: True if a match; otherwise False

    Note: when performing comparisons, use constant time functions,
          e.g. constant_time.bytes_eq in cryptography library
    """
    if not isinstance(data, bytes):
        raise CryptoException("Data value must be in bytes")
    if not isinstance(mac, bytes):
        raise CryptoException("MAC value must be in bytes")
    computed_hash = hash_message(data, hash_method)
    return bytes_eq(computed_hash, mac)

def verify_hmac(data, hash_method, key, mac):
    """
    Verify that a given HMAC is correct for some data

    :param data: the data on which the HMAC is supposedly computed (byte string)
    :param hash_method: the hash method supposedly used -- one of "SHA256" or "SHA512" (string)
    :param key: the key supposedly used in HMAC (byte string)
    :param mac: the hash value to match against (byte string)
    :return: True if a match; otherwise False
    """
    if not isinstance(data, bytes):
        raise CryptoException("Data value must be in bytes")
    if not isinstance(key, bytes):
        raise CryptoException("Key value must be in bytes")
    if not isinstance(mac, bytes):
        raise CryptoException("MAC value must be in bytes")
    computed_hmac = hmac_message(data, hash_method, key)
    return bytes_eq(computed_hmac, mac)

def pad_data(data, block_size):
    padding_length = block_size - (len(data) % block_size)
    padding = bytes([padding_length]) * padding_length
    return data + padding

def sym_encrypt(data, sym_key, algo, chain_mode, mac_key=None, mac_mode=None):
    try:
        # Validate key lengths
        if algo == "AES128" and len(sym_key) != 16:
            raise CryptoException("AES sym_key must be 128 bits (16 bytes)")
        elif algo == "ChaCha20" and len(sym_key) != 32:
            raise CryptoException("ChaCha20 sym_key must be 256 bits (32 bytes)")

        # Validate chaining mode
        if chain_mode not in ["CBC", "CTR", "GCM"]:
            raise CryptoException("Invalid chaining mode")

        # Generate IV/nonce securely
        if chain_mode == "GCM" and algo == "AES128":
            iv_length = 12  # GCM mode requires a 12-byte nonce
        else:
            iv_length = 16  # IV length for AES/CBC and ChaCha20

        iv = generate_random_securely(iv_length)

        # Select encryption algorithm and mode
        if algo == "AES128":
            algorithm = algorithms.AES(sym_key)
            # Pad the data if necessary
            if chain_mode in ["CBC", "CTR"]:
                data = pad_data(data, 16)  # Pad to AES block size (16 bytes)
                if chain_mode == "CBC":
                    mode = modes.CBC(iv)
                elif chain_mode == "CTR":
                    mode = modes.CTR(iv)
            elif chain_mode == "GCM":
                mode = modes.GCM(iv)
            else:
                raise CryptoException("Invalid chaining mode for AES")
        elif algo == "ChaCha20":
            algorithm = algorithms.ChaCha20(sym_key, iv)
            if chain_mode in ["CBC", "CTR", "GCM"]:
                mode = None
            else:
                raise CryptoException("Invalid chaining mode for ChaCha20")
        else:
            raise CryptoException("Invalid algorithm")

        # Perform encryption
        cipher = Cipher(algorithm, mode, backend=default_backend())
        encryptor = cipher.encryptor()
        ct = encryptor.update(data) + encryptor.finalize()

        # Compute MAC if mac_mode is specified
        mac = None
        if mac_mode:
            if algo == "AES128" and chain_mode == "GCM":
                mac = encryptor.tag
            elif mac_key:
                h = hmac.HMAC(mac_key, hashes.SHA256(), backend=default_backend())
                h.update(ct)
                mac = h.finalize()

        return iv, ct, mac

    except Exception as e:
        raise CryptoException("Error during encryption: {}".format(str(e)))

def sym_decrypt(data, sym_key, iv, algo, chain_mode, mac_key=None, mac=None, mac_mode=None):
    try:
        if algo == "AES128":
            if len(sym_key) != 16:
                raise CryptoException("AES key must be 128 bits (16 bytes)")
            if chain_mode == "CBC":
                cipher = Cipher(algorithms.AES(sym_key), modes.CBC(iv), backend=default_backend())
            elif chain_mode == "CTR":
                cipher = Cipher(algorithms.AES(sym_key), modes.CTR(iv), backend=default_backend())
            elif chain_mode == "GCM":
                cipher = Cipher(algorithms.AES(sym_key), modes.GCM(iv, mac), backend=default_backend())
            else:
                raise CryptoException("Invalid chaining mode")
        elif algo == "ChaCha20":
            if len(sym_key) != 32:
                raise CryptoException("ChaCha20 key must be 256 bits (32 bytes)")
            if chain_mode in ["CBC", "CTR", "GCM"]:
                cipher = Cipher(algorithms.ChaCha20(sym_key, iv), mode=None, backend=default_backend())
            else:
                raise CryptoException("Invalid chaining mode")
        else:
            raise CryptoException("Invalid algorithm")

        decryptor = cipher.decryptor()
        pt = decryptor.update(data) + decryptor.finalize()

        if mac_mode:
            if algo == "AES128" and chain_mode == "GCM":
                # For AES128-GCM, verify the MAC against the one expected by GCM
                mac = mac
                if mac != decryptor._tag:
                    raise CryptoException("Invalid MAC")
            elif mac_key:
                computed_mac = hmac_message(data, "SHA256", mac_key)
                if not constant_time.bytes_eq(computed_mac, mac):
                    raise CryptoException("MAC verification failed")

        return pt
    except InvalidSignature:
        raise CryptoException("Invalid MAC")
    except Exception as e:
        raise CryptoException("Error during decryption: {}".format(str(e)))

def gen_rsa_keypair(size):
    '''
    Generate a RSA public and private keypair

    :param size: key size (integer)
    :return: a tuple (pu, pr) - each a RSAPrivateKey instance of cryptography library
             pu: public key
             pr: private key
    '''
    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=size
    )
    public_key = private_key.public_key()
    return public_key, private_key


def gen_ec_keypair():
    '''
    Generate a P-256 elliptic curve public and private keypair

    :return: a tuple (pu, pr) - each an EllipticCurvePrivateKey instance of cryptography library
             pu: public key
             pr: private key
    '''
    private_key = ec.generate_private_key(ec.SECP256R1())
    public_key = private_key.public_key()
    return public_key, private_key


def save_public_key(public_key, file):
    '''
    Serialize and saves a RSAPublicKey or EllipticCurvePublicKey instance as a PEM file

    :param public_key: the public key (RSAPublicKey or EllipticCurvePublicKey)
    :param file: output file name (use .pem extension) (string)
    '''
    try:
        with open(file, "wb") as f:
            f.write(public_key.public_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PublicFormat.SubjectPublicKeyInfo
            ))
    except Exception as e:
        raise CryptoException(f"Error saving public key to file: {str(e)}")


def save_private_key(private_key, file, password=None):
    '''
    Serialize and saves a RSAPrivateKey or EllipticCurvePrivateKey instance as a PEM file

    :param private_key: the private key (RSAPrivateKey or EllipticCurvePrivateKey)
    :param password: optional password to encrypt saved file (byte string)
    :param file: output file name (use .pem extension) (string)
    '''
    try:
        encryption_algorithm = serialization.NoEncryption()
        if password is not None:
            encryption_algorithm = serialization.BestAvailableEncryption(password)

        with open(file, "wb") as f:
            f.write(private_key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.PKCS8,
                encryption_algorithm=encryption_algorithm
            ))
    except Exception as e:
        raise CryptoException(f"Error saving private key to file: {str(e)}")


def load_public_key(file):
    '''
    Load a RSAPublicKey or EllipticCurvePublicKey from a PEM file

    :param file: input file name (string)
    :return: the public key (RSAPublicKey or EllipticCurvePublicKey)
    '''
    try:
        with open(file, "rb") as f:
            key_data = f.read()
            return serialization.load_pem_public_key(key_data)
    except Exception as e:
        raise CryptoException(f"Error loading public key from file: {str(e)}")


def load_private_key(file, password=None):
    '''
    Load a RSAPrivateKey or EllipticCurvePrivateKey from a PEM file

    :param file: input file name (string)
    :param password: optional password to decrypt input file, if it was saved with encryption (byte string)
    :return: the private key (RSAPrivateKey or EllipticCurvePrivateKey)
    '''
    try:
        with open(file, "rb") as f:
            key_data = f.read()
            return serialization.load_pem_private_key(key_data, password=password)
    except Exception as e:
        raise CryptoException(f"Error loading private key from file: {str(e)}")


def rsa_encrypt(data, public_key):
    '''
    Encrypt some data using RSA

    :param data: data to encrypt (byte string)
    :param public_key: public key to use (RSAPublicKey)
    :return: ciphertext (byte string)

    Note: The amount of data you can encrypt will be limited. Experiment!
    '''
    try:
        return public_key.encrypt(
            data,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
    except Exception as e:
        raise CryptoException(f"Error encrypting data with RSA: {str(e)}")


def rsa_decrypt(data, private_key):
    '''
    Decrypt some data using RSA

    :param data: data to decrypt (byte string)
    :param private_key: private key to use (RSAPrivateKey)
    :return: plaintext (byte string)
    '''
    try:
        return private_key.decrypt(
            data,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
    except Exception as e:
        raise CryptoException(f"Error decrypting data with RSA: {str(e)}")


def rsa_envelope_encrypt(data, public_key):
    '''
    Envelope encrypt some data using RSA and AES128-GCM

    :param data: data to encrypt (byte string)
    :param public_key: public key to use (RSAPublicKey)
    :return: a four tuple (key_ct, iv, ct, mac) - each a byte string
             key_ct: ciphertext of symmetric key
             iv: initial value used in symmetric encryption
             ct: ciphertext of data
             mac: GCM computed MAC on data

    Note: Although not necessary here, key_ct can be provided as "additional authentication data" to
          GCM so that we can have integrity protection on key_ct as well
    '''
    sym_key = generate_random_securely(16)
    iv, ct, mac = sym_encrypt(data, sym_key, "AES128", "GCM")
    try:
        key_ct = public_key.encrypt(
            sym_key,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
    except Exception as e:
        raise CryptoException(f"Error encrypting symmetric key with RSA: {str(e)}")
    return key_ct, iv, ct, mac


def rsa_envelope_decrypt(data, key_data, iv, mac, private_key):
    '''
    Decrypt some data envelope encrypted using RSA and AES128-GCM

    :param data: data to decrypt (byte string)
    :param key_data: encrypted symmetric key (byte string)
    :param iv: initial value used in symmetric encryption (byte string)
    :param mac: MAC on data to compare against
    :param private_key: private key to use (RSAPrivateKey)
    :return: plaintext (byte string)

    Note: The function should raise a CryptoException if the MAC is invalid
    '''
    try:
        sym_key = private_key.decrypt(
            key_data,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
    except Exception as e:
        raise CryptoException(f"Error decrypting symmetric key with RSA: {str(e)}")
    try:
        plaintext = sym_decrypt(data, sym_key, iv, "AES128", "GCM", mac=mac)
        return plaintext
    except CryptoException as e:
        raise CryptoException(f"Error decrypting data: {str(e)}")

def generate_signature(data, method, private_key):
    '''
    Sign some data using RSA/ECDSA with SHA256

    :param data: data to sign (byte string)
    :param method: signing method - one of "RSA" or "ECDSA" (string)
    :param private_key: private key to use for signing (RSAPrivateKey or EllipticCurvePrivateKey)
    :return: signature (byte string)
    '''
    if not isinstance(data, bytes):
        raise CryptoException("Data value must be in bytes")
    if method == "RSA":
        try:
            return private_key.sign(
                data,
                padding.PSS(
                    mgf=padding.MGF1(hashes.SHA256()),
                    salt_length=padding.PSS.MAX_LENGTH
                ),
                hashes.SHA256()
            )
        except Exception as e:
            raise CryptoException(f"Error generating RSA signature: {str(e)}")
    elif method == "ECDSA":
        try:
            return private_key.sign(
                data,
                ec.ECDSA(hashes.SHA256())
            )
        except Exception as e:
            raise CryptoException(f"Error generating ECDSA signature: {str(e)}")
    else:
        raise CryptoException("Invalid signing method. Supported methods: RSA, ECDSA")

def verify_signature(data, method, public_key, signature):
    '''
    Verify a RSA/ECDSA with SHA256 signature on some data

    :param data: data on which signature is generated (byte string)
    :param method: signing method - one of "RSA" or "ECDSA" (string)
    :param public_key: public key to use for verification (RSAPublicKey or EllipticCurvePublicKey)
    :param signature: the signature to verify against (byte string)
    :return: True if signature is valid; otherwise False
    '''
    if not isinstance(data, bytes):
        raise CryptoException("Data value must be in bytes")
    if not isinstance(signature, bytes):
        raise CryptoException("Signature value must be in bytes")
    if method == "RSA":
        try:
            public_key.verify(
                signature,
                data,
                padding.PSS(
                    mgf=padding.MGF1(hashes.SHA256()),
                    salt_length=padding.PSS.MAX_LENGTH
                ),
                hashes.SHA256()
            )
            return True
        except InvalidSignature:
            return False
        except Exception as e:
            raise CryptoException(f"Error verifying RSA signature: {str(e)}")
    elif method == "ECDSA":
        try:
            public_key.verify(
                signature,
                data,
                ec.ECDSA(hashes.SHA256())
            )
            return True
        except InvalidSignature:
            return False
        except Exception as e:
            raise CryptoException(f"Error verifying ECDSA signature: {str(e)}")
    else:
        raise CryptoException("Invalid signing method. Supported methods: RSA, ECDSA")

def gen_rsa_keypair(size):
    '''
    Generate a RSA public and private keypair

    :param size: key size (integer)
    :return: a tuple (pu, pr) - each a RSAPrivateKey instance of cryptography library
             pu: public key
             pr: private key
    '''
    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=size,
        backend=default_backend()
    )
    public_key = private_key.public_key()
    return public_key, private_key

def gen_ec_keypair():
    '''
    Generate a P-256 elliptic curve public and private keypair

    :return: a tuple (pu, pr) - each an EllipticCurvePrivateKey instance of cryptography library
             pu: public key
             pr: private key
    '''
    private_key = ec.generate_private_key(
        ec.SECP256R1(),
        default_backend()
    )
    public_key = private_key.public_key()
    return public_key, private_key

def save_public_key(public_key, file):
    '''
    Serialize and saves a RSAPublicKey or EllipticCurvePublicKey instance as a PEM file

    :param public_key: the public key (RSAPublicKey or EllipticCurvePublicKey)
    :param file: output file name (use .pem extension) (string)
    '''
    with open(file, "wb") as f:
        f.write(public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        ))

def save_private_key(private_key, file, password=None):
    '''
    Serialize and saves a RSAPrivateKey or EllipticCurvePrivateKey instance as a PEM file

    :param private_key: the private key (RSAPrivateKey or EllipticCurvePrivateKey)
    :param password: optional password to encrypt saved file (byte string)
    :param file: output file name (use .pem extension) (string)
    '''
    encryption_algorithm = serialization.NoEncryption()
    if password:
        encryption_algorithm = serialization.BestAvailableEncryption(password)
    with open(file, "wb") as f:
        f.write(private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.TraditionalOpenSSL,
            encryption_algorithm=encryption_algorithm
        ))
def test_generate_random_securely():
    try:
        # Generate a secret key of 16 bytes (128 bits) and print it
        size = 16
        secret_key = generate_random_securely(size)
        print("Generated secret key:", secret_key.hex())
    except CryptoException as e:
        print("Error:", e)
def test_crypto_functions():
    # Test generate_random_securely function
    random_bytes = generate_random_securely(32)
    print("Generated Random Bytes:", random_bytes.hex())

    # Test hash_message function
    data_to_hash = b"Hello, world!"
    hash_method = "SHA256"
    hashed_data = hash_message(data_to_hash, hash_method)
    print("Hashed Data (SHA256):", hashed_data.hex())

    # Test hmac_message function
    key = generate_random_securely(32)
    hmac = hmac_message(data_to_hash, hash_method, key)
    print("HMAC:", hmac.hex())

    # Test verify_hash function
    is_hash_valid = verify_hash(data_to_hash, hash_method, hashed_data)
    print("Hash Validation:", is_hash_valid)

    # Test verify_hmac function
    is_hmac_valid = verify_hmac(data_to_hash, hash_method, key, hmac)
    print("HMAC Validation:", is_hmac_valid)

def test_rsa_keypair_generation():
    size = 2048  # Choose a key size, e.g., 2048 bits
    public_key, private_key = gen_rsa_keypair(size)

    # Print public key
    print("RSA Public Key:")
    print(public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo
    ).decode())

    # Print private key
    print("RSA Private Key:")
    print(private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.PKCS8,
        encryption_algorithm=serialization.NoEncryption()
    ).decode())

    # Save keys to files
    save_public_key(public_key, "rsa_public.pem")
    save_private_key(private_key, "rsa_private.pem")
def test_ec_keypair_generation():
    public_key, private_key = gen_ec_keypair()

    # Print EC Public Key
    print("EC Public Key:")
    print(public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo
    ).decode())

    # Print EC Private Key
    print("EC Private Key:")
    print(private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.PKCS8,
        encryption_algorithm=serialization.NoEncryption()
    ).decode())

    # Save keys to files
    save_public_key(public_key, "ec_public.pem")
    save_private_key(private_key, "ec_private.pem")

def test_symmetric_crypto():
    # Sample data
    data = b"Hello, World!"

    # Symmetric key
    sym_key_aes = b"0123456789abcdef"  # 16 bytes for AES128
    sym_key_chacha = b"0123456789abcdef0123456789abcdef"  # 32 bytes for ChaCha20

    # MAC key
    mac_key = b"fedcba9876543210"  # 16 bytes

    # Encryption with AES128-CBC-EAM
    iv_aes, ct_aes, mac_aes = sym_encrypt(data, sym_key_aes, "AES128", "CBC", mac_key, "EAM")
    print("AES128-CBC-EAM Ciphertext:", ct_aes.hex())
    print("AES128-CBC-EAM MAC:", mac_aes.hex())

    # Decryption with AES128-CBC-EAM
    try:
        pt_aes = sym_decrypt(ct_aes, sym_key_aes, iv_aes, "AES128", "CBC", mac_key, mac_aes, "EAM")
        print("AES128-CBC-EAM Plaintext:", pt_aes.decode())
    except CryptoException as e:
        print("AES128-CBC-EAM Decryption failed:", e)

    # Encryption with ChaCha20-CTR-MTE
    iv_chacha, ct_chacha, mac_chacha = sym_encrypt(data, sym_key_chacha, "ChaCha20", "CTR", mac_key, "MTE")
    print("\nChaCha20-CTR-MTE Ciphertext:", ct_chacha.hex())
    print("ChaCha20-CTR-MTE MAC:", mac_chacha.hex())

    # Decryption with ChaCha20-CTR-MTE
    try:
        pt_chacha = sym_decrypt(ct_chacha, sym_key_chacha, iv_chacha, "ChaCha20", "CTR", mac_key, mac_chacha, "MTE")
        print("ChaCha20-CTR-MTE Plaintext:", pt_chacha.decode())
    except CryptoException as e:
        print("ChaCha20-CTR-MTE Decryption failed:", e)

def test_rsa_encrypt_decrypt():
    try:
        # Generate RSA key pair
        public_key, private_key = gen_rsa_keypair(2048)

        # Data to encrypt
        data = b"Hello, RSA encryption and decryption!"

        # Encrypt data
        ciphertext = rsa_encrypt(data, public_key)
        print("Ciphertext:", ciphertext.hex())

        # Decrypt data
        decrypted_data = rsa_decrypt(ciphertext, private_key)
        print("Decrypted Data:", decrypted_data.decode())
    except CryptoException as e:
        print("Error:", e)


def print_ba(b, prefix=''):
    '''
    Print byte string as hex string in the format:
         [prefix] <hex string> (<bit length of input>)

    :param b: byte string (byte string)
    :param prefix: prefix to be printed before the hex string (string)
    '''
    print(prefix, end="")
    if b is not None:
        print('0x' + ''.join(format(x, '02x') for x in b), end="")
        print(' (' + str(len(b) * 8) + ' bits)')
    else:
        print('None')

if __name__ == "__main__":
    test_generate_random_securely()
    test_crypto_functions()
    test_symmetric_crypto()
    test_ec_keypair_generation()
    test_rsa_keypair_generation()
    test_rsa_encrypt_decrypt()



#NOTE the PEM files are displayed under the project both ec and rsa

